---
- name: Build and deploy Java Tomcat app on Minikube
  hosts: localhost
  gather_facts: no # No need for facts in this simple playbook

  vars:
    # --- Project/Image variables ---
    project_path: "{{ lookup('env', 'WORKSPACE') | default('.', true) }}" # Use '.' for current dir if running manually
    image_name: aman8997abc/my-tomcat-app # Your Docker Hub username/repo name
    image_tag: 1.0                       # Tag matching your manual build
    
    # --- Kubernetes application variables (make consistent with your .yaml files) ---
    k8s_app_name: aman-abc-tech          # Label/selector used in K8s YAMLs
    deployment_name: aman-abc-tech-deployment # Name of the K8s Deployment
    service_name: aman-abc-tech-service   # Name of the K8s Service
    k8s_container_port: 8080             # Port application listens on inside the container (Tomcat)
    k8s_service_port: 80                 # Port the K8s Service listens on externally (e.g., HTTP)
    k8s_service_type: NodePort           # How to expose the service (NodePort for Minikube)
    namespace: default                   # Kubernetes namespace

    # --- Docker Hub credentials (passed as extra-vars or Jenkins credentials) ---
    dockerhub_username: "{{ lookup('env', 'DOCKERHUB_USERNAME') | default(omit) }}"
    dockerhub_password: "{{ lookup('env', 'DOCKERHUB_PASSWORD') | default(omit) }}"

  tasks:
    - name: Ensure project_path is correct for manual runs if WORKSPACE is not set
      set_fact:
        project_path: "{{ ansible_facts.env.PWD }}"
      when: lookup('env', 'WORKSPACE') == None

    - name: Build Docker image
      community.docker.docker_image:
        name: "{{ image_name }}"
        tag: "{{ image_tag }}"
        source: build
        build:
          path: "{{ project_path }}" # Build context is the project root where Dockerfile and target/ are
          args:
            WAR_FILE_NAME: "ABCtechnologies-1.0.war" # Pass the WAR file name as a build argument
      register: docker_build_result
      changed_when: docker_build_result.changed or (docker_build_result.image is defined and docker_build_result.image.id is defined)
      failed_when: docker_build_result.failed

    - name: Log in to Docker Hub
      community.docker.docker_login:
        username: "{{ dockerhub_username }}"
        password: "{{ dockerhub_password }}"
        registry: docker.io
      when: dockerhub_username is defined and dockerhub_password is defined # Only run if credentials are provided
      no_log: true # Prevent sensitive info from being logged

    - name: Push Docker image to Docker Hub
      community.docker.docker_image:
        name: "{{ image_name }}"
        tag: "{{ image_tag }}"
        source: local
        push: true
      when: dockerhub_username is defined and dockerhub_password is defined # Only push if credentials are provided

    - name: Delete existing Kubernetes deployment (if any)
      kubernetes.core.k8s:
        state: absent
        api_version: apps/v1
        kind: Deployment
        name: "{{ deployment_name }}"
        namespace: "{{ namespace }}"
      ignore_errors: true # Ignore if not found

    - name: Delete existing Kubernetes service (if any)
      kubernetes.core.k8s:
        state: absent
        api_version: v1
        kind: Service
        name: "{{ service_name }}"
        namespace: "{{ namespace }}"
      ignore_errors: true # Ignore if not found

    - name: Apply new Kubernetes deployment
      ansible.builtin.template:
        src: deployment.yaml.j2 # This assumes you have ansible/templates/deployment.yaml.j2
        dest: /tmp/deployment.yaml
      when: true

    - name: Create Kubernetes Deployment
      kubernetes.core.k8s:
        state: present
        definition: "{{ lookup('file', '/tmp/deployment.yaml') }}"
        namespace: "{{ namespace }}"

    - name: Apply new Kubernetes service
      ansible.builtin.template:
        src: service.yaml.j2 # This assumes you have ansible/templates/service.yaml.j2
        dest: /tmp/service.yaml
      when: true

    - name: Create Kubernetes Service
      kubernetes.core.k8s:
        state: present
        definition: "{{ lookup('file', '/tmp/service.yaml') }}"
        namespace: "{{ namespace }}"

    - name: Wait for deployment rollout to complete
      kubernetes.core.k8s_info:
        api_version: apps/v1
        kind: Deployment
        name: "{{ deployment_name }}"
        namespace: "{{ namespace }}"
        wait: true
        wait_condition:
          type: Available
          status: "True"
        wait_timeout: 300 # Wait up to 5 minutes

    - name: Get Minikube service URL
      shell: "minikube service {{ service_name }} --url --namespace {{ namespace }}"
      register: minikube_service_url

    - name: Display Minikube service URL
      debug:
        msg: "Application available at: {{ minikube_service_url.stdout }}"

    - name: Verify application accessibility
      uri:
        url: "{{ minikube_service_url.stdout }}"
        method: GET
        status_code: [200, 301, 302] # Allow redirects for web apps
        validate_certs: false # Use false for development/self-signed certs
      register: uri_result
      changed_when: false
      failed_when: uri_result.status not in [200, 301, 302]
      
    - debug:
        msg: "Application verification successful!"
      when: uri_result.status in [200, 301, 302]
